# 30. Метод ветвей и границ на примере минимаксной задачи теории расписаний. Приближенные алгоритмы решения NP-трудных задач: упаковка в контейнеры, рюкзак, коммивояжер, расписание для многопроцессорной системы, вершинное покрытие. Оценки их сложности и погрешности.

Метод ветвей и границ относится к точным алгоритмам. Для метода ветвей и границ необходимы две процедуры: ветвление и нахождение оценок (границ). Пусть есть оптимальная задача $\min\limits_{x \in X}f(x)$. Ветвление разделяет множество $X = X_1 \cup X_2$ . Вычисляются оценки на этих множествах (нижние и верхние)  $F_{1l} \le \min\limits_{x \in X_1}f(x) \le F_{1h}$  и  $F_{2l} \le \min\limits_{x \in X_2}f(x) \le F_{2h}$. Если $F_{1h} \le F_{2l}$ , то можно не рассматривать $X_2$ и осуществлять ветвление дальше только на $X_1$.

**Минимаксная задача построения расписания для многопроцессорной системы**: имеется вычислительная система $P = P_1, \dots, P_m $ , состоящая из $m$ процессоров. Дано $n$ работ $T = T_1, \dots, T_n$, для каждой из которых известна длительность  $t_{ij}$ на процессоре $P_j$. Требуется распределить задания по процессорам так, чтобы общее время выполнения всего множества работ было минимальным.

Ветвление: на первом уровне определяется размещение 1 работы ---  $m$ вариантов, далее рекурсивно на уровне $k$ определяется процессор для работы $k$.

Оценки:

* Нижняя (на уровне $k$, то есть известно размещение первых $k$ работ ): 

  * $L_1 = \max\limits_{j= \overline{1,m}} T_j$, где  $T_j$ - текущее время выполнения размещенных работ на процессоре  $j$. Общая длительность расписания будет не меньше уже существующей.
  * $L_2 = \max\limits_{i=\overline{k+1,n}} \min\limits_{j=\overline{1,m}} (T_j + t_{ij})$  - длительность расписания увеличится еще на одну размещенную работу (самым быстрым способом)
  * $L_3 = (\sum\limits_{j=1}^mT_j + \sum\limits_{i=k+1}^n \min\limits_{j=\overline{1,m}}t_{ij}){1 \over m}$  - учет размещение всех работ, не размещенных к данному ветвлению

  Итоговая нижняя оценка $L = \max(L_1, L_2, L_3)$

* Верхняя  (на уровне $k$, то есть известно размещение первых $k$ работ ): неназначенные работы распределяются жадным алгоритмом и  $H = \max\limits_{j=\overline{1,m}}T^*_j$, где $T_j^*$ - длительность работ на процессорах с учетом распределения остальных работ жадным алгоритмом.



Приближенным алгоритмом для задачи $П$ называется полиномиальный по времени алгоритм, возвращающий для каждого входа $I \in D_{П}$  какое-то решение $x(I) \in sol(I)$. Обозначим через $f(x_A(I))$ стоимость решения, найденного алгоритмом А на входе $I$. Пусть $f(x^*(I)) = \min\limits_{x(i) \in sol(I)}f(x(I))$ - оптимальная стоимость решения.

Часто рассматриваются следующие **виды погрешностей** для индивидуальных задач $I$:

$r^1_A(I) = {f(x_A(I)) \over f(x^*(I))}$ - во сколько раз больше решение

$r^2_A(I) = {f(x_A(I)) - f(x^*(I))}$ - разность

$r^3_A(I) = { {f(x_A(I)) - f(x^*(I))} \over f(x^*(I))}$ -  относительная погрешность

$r^3_A(I) = r_A^1(I) - 1$

**Погрешности** для алгоритма определяются следующим образом:

$r^1_A = \sup\limits_{I \in D_П} r_A^1(I)$ - погрешность алгоритма в целом

$r^2_A = \sup\limits_{I \in D_П} r_A^2(I)$ -  - погрешность алгоритма в целом



**Упаковка**

Упаковка $N$ объектов (каждый своего объёма $v_i$) в конечное число контейнеров (объём контейнеров фиксирован $V$) таким способом, чтобы число использованных контейнеров было наименьшим.

Алгоритм: 

Первый походящий:  объекты помещаются в первый подходящий контейнер, если не помещаются, то создается новый.

Погрешность: $r^1_A \le 2$ , так как все контейнеры, максимум кроме одного будут заполнены на половину, значит $\sum\limits_{i \in N}v_i \ge {V \over 2}f(x_A(I))$, следовательно $f(x_A(I)) <2 \cdot {\sum\limits_{i \in N}v_i \over V}$, но ${\sum\limits_{i \in N}v_i \over V} \le f(x^*(I))$  

Сложность $O(n^2)$ 

>  Если объемы упорядочить по невозрастанию, то $r_A^1 \le {11 \over 9}$

**Рюкзак**

Из заданного множества предметов со свойствами стоимость и вес, требуется отобрать некое число предметов таким образом, чтобы получить максимальную суммарную стоимость при одновременном соблюдении ограничения на суммарный вес.

Алгоритм: 

Жадный алгоритм: необходимо отсортировать вещи по их удельной ценности (то есть отношению ценности предмета к его весу), и поместить в рюкзак предметы с наибольшей удельной ценностью. 

Итоговая сложность $O(N\log(N))$ 

Погрешность: $r_A^1 \le 2$



**Коммивояжер**

Пройти все вершины неориентированного графа $G = V, A$  с весами $d_{ij}, (i,j) \in A$ ровно по одному разу и вернуться в исходную вершину. Необходимо найти такой обход графа с минимальной суммой весов пройденных рёбер.

Алгоритм:

1. Ищем минимальное остовное дерево (МОД)  $f(x_{МОД}(I)) < f(x^*(I))$
   1. $V' = \empty , A' = \empty$
   2. Добавляем вершину $i=1$ в $V'$
   3. Ищем ребро $(i_0, j_0)$ , такое что $d_{i_0j_0} = \min\limits_{i \in V', ~ j \in V \setminus V', ~ (i,j) \in A} d_{ij}$ .  Вершина $j_0$ добавляется в $V'$,  а ребро $(i_0,j_0)$ в $A'$
2. Используем двойной обход по МОД  ($f(x_2(I)) < 2 f(x^*(I))$)
3. Строим маршрут коммивояжера ($f(x_A(I)) < 2 f(x^*(I))$)

Погрешность: $r_A^1 \le 2$

Сложность: $O(n^3)$ 



**Вершинное покрытие**

Выбрать в неориентированном графе G = (V, E) минимальное (по количеству вершин) множество вершин S так, чтобы оно покрывало все рёбра графа. То есть так, чтобы у каждого из рёбер графа хотя бы один из концов принадлежал S.

Алгоритм:

1. $V' = \empty$
2. Выбираем ребро $(i,j) \in E$,  добавляем вершины $i,j$ в множество $V'$
3. Удаляем все инцидентные этим вершинам ребра $A$ , $ E := E \setminus A $. Если еще есть ребра, то перейти к шагу 2.

Погрешность $r^1_A \le 2$, так как, если $|V'| = f(x_A(I)) = 2K$, то $f(x^*(I)) \ge K$

Сложность $O(n^2)$