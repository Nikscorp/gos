# 5. Принципы организации и основные достоинства MPLS технологии.

Проблема: протоколам маршрутизации для передачи пакета на следующий хоп нужно смотреть заголовок пакета и локальную таблицу маршрутизации, причем это происходит на каждом хопе. Таким образом на каждом маршрутизаторе по сути нужно иметь полную таблицу маршрутизации и делать лукап по адресу назначения на каждом хопе.

Решение: MPLS — уменьшает оверхед на непосредственно маршрутизацию, может маршрутизировать не только IP.

BTW

На самом деле сейчас стала широко доступна аппаратная IP маршрутизация, поэтому лучше сказать, что MPLS решает проблему универсальности доставки — совершенно неважно, что находится под меткой — IP, Ethernet, ATM, Frame Relay. В основном сейчас MPLS применяется для VPN и TE. Еще один плюс применения чистого MPLS — возможность сделать так, чтобы не нужно было настраивать BGP на каждом роутере для IBGP, достаточно раутить по меткам. 

## MPLS Control Plane

<img src="img/Screenshot 2020-05-26 at 20.26.35.png" alt="Screenshot 2020-05-26 at 20.26.35" style="zoom: 33%;" />

Заполняется новая таблица с метками, метками обмениваются как и IP адресами, заполняется соответствующие таблицы.

## MPLS Data Plane

<img src="img/Screenshot 2020-05-26 at 20.26.53.png" alt="Screenshot 2020-05-26 at 20.26.53" style="zoom:33%;" />

Маршрутизация может проводится на основе обоих таблиц.

## MPLS устройства

**LSR** — маршрутизатор в домене MPLS. Передает и принимает только пакеты с метками. Может менять метки при передаче пакета.

**Edge LSR** — стоит на границе MPLS домена. Производит установку первой метки при входе в MPLS домен и снятия последней при выходе из домена.

LSR, которые не Edge будем называть **core LSR**.

Сами Edge по понятному принципу делятся на **Ingress Edge LSR** и **Egress Edge LSR** (вход и выход из MPLS домена соотвественно)

Таким образом исходный лукап в таблицу маршрутизации происходит только на Edge LSR. Остальные LSR делают лукап по меткам только в Label Forwarding Table.

## MPLS метки

- Определяют FEC (forwarding equivalence class) — класс эквивалентности маршрутизации — по сути это IP + маска на egress.
- Имеют локальную значимость. Каждый LSR сам выбирает метку и FEC и передает эту информацию другим LSR, инициирует этот процесс edge LSR.

По сути FEC — это группа пакетов, которые передаются по одному пути. MPLS маршрутизация состоит из назначения пакета на FEC, определения следующего хода для FEC.

MPLS метка имеет размер 32 бита из которых:

- Первые 20 — сама метка
- 3 бита — TC (Traffic class) — очередной QoS
- Индикатор S — 1 бит — указывает последняя ли это метка перед IP пакетом (нужно для парсинга)
- 8 бит TTL — копируется из IP пакета

Сама метка находится между 2 и 3 уровнями TCP/IP. То есть IP пакет сначала заворачиваем в MPLS, а затем уже в L2 фрейм.

В лекции выделяют:

- Frame-mode MPLS. Именно то, что описано выше, кладем информацию между 2 и 3 уровнями.
- Cell-mode MPLS is MPLS over ATM. Есть такой L2 протокол ATM. Там есть куда куда впихнуть метки в самом протоколе, дополнительные сущности таким образом не нужны.

Для задач маршрутизации обычно достаточно одной метки, но с помощью MPLS можно организовывать всякие сложные вещи, увеличивая количество меток:

- MPLS VPNs (2 метки): Одна метка для маршрутизации, другая для указания VPN (туннеля).
- MPLS TE (2 и больше меток): Тут подразумевается, например, балансировка нагрузки, одна из меток позволяет указать класс (туннель) TE.
- Все вместе: много меток

Последняя метка всегда используется для маршрутизации.

Парсить все это просто. Для L2 пакетов есть EtherType, указывающий, что пакет начинается с метки *0x8847* (на самом деле тут еще указано, что это юникаст), дальше снимаем по 32 бита и смотрим на индикатор S.

## Операции над MPLS метками

Ранее говорилось, что LSR может менять метки при передаче пакета. Что это, зачем это.

LSR может сделать 3 вещи:

- Вставить одну или несколько меток (Ingress Edge LSR)

- Поменять одну или несколько меток (core LSR)

- Удалить метку (pop) (Egress Edge LSR)

Пример:

<img src="img/Screenshot 2020-05-26 at 21.01.59.png" alt="Screenshot 2020-05-26 at 21.01.59" style="zoom: 50%;" />

##  Практическое применение MPLS

Применение:

- Unicast IP routing 

- Multicast IP routing 

- MPLS TE
- QoS
- MPLS VPNs (на этом кстати фокусировался по хорошему наш курс)
- AToM (раньше про это не было, это возможность завернуть любой L2 в MPLS и другой L2)

Более подробно будем рассматривать только Unicast IP routing (база) и MPLS VPNs (слишком много про это было в курсе).

Для начала нужно разобраться как обнаруживать соседей и передавать метки, мы же все таки маршрутизацией занимаемся.

## Присваивание и распространение меток

### Обнаружение соседей

Метки распространяются благодаря алгоритму LDP (Label Distribution Protocol).

Установление сессии:

1. Рассылка Hello сообщений (UDP multicast на адреса в той же подсети с TTL 1) на интерфейсы, с MPLS enabled
2. Ответ на Hello сообщение — попытка установить сессию (на самом деле инициатором установки соединения будет тот LSR у которого IP больше)

Сама сессия устанавливается по TCP.

После этого происходит обмен инициализационными сообщениями и начинают посылаться keepalive сообщения.

Несмежные соседи могут соединяться схожим образом, только вместо multicast — unicast, это называется tLDP, иногда это нужно.

### Распространение меток

<img src="img/Screenshot 2020-05-27 at 05.08.49.png" alt="Screenshot 2020-05-27 at 05.08.49" style="zoom:50%;" />

Подробного описания нет, но все достаточно очевидно — посылаем соседям те метки и IP адреса, которые у нас есть — при получении заполняем LIB, FIB и LFIB. Отметим, что без отработавшего OSPF это все работать не будет.

Но откуда вообще взять метки? Для этого нужен инициатор, про это ниже.

### Label-Switched Path и построение пути

LSP — последовательность LSR, передающих помеченные пакеты определенного FEC.

Таким образом:

- Строятся LSP исходя из IP маршрутизации (например OSPF)
- LDP распространяет метки на отдельные сегменты LSP.

Все происходит примерно так:

- Egress роутер обнаруживает изменение в таблице маршрутизации
- Выбирает какой нибудь FEC (ip+маска из dst таблицы маршрутизации) и выбирает для нее метку (любую) (так происходит для всех dest)
- Эту информацию он через LDP передает своим соседям
- Соседи генерируют свою метку, заполняют LIB, FIB и LFIB и передают своим соседям
- В итоге построен LSP путь
- Если найдено несколько путей используется лучший по некоторой метрике (как и в других алгоритмах маршрутизации)
- Гифка из СДСМ: https://gblobscdn.gitbook.com/assets%2F-LIgRTPaaN7wUujKIWEz%2F-LXhL-JzPMdG-IAZwDzA%2F-LXhLLisFxolb93jgcCx%2Fb1371acab49e47c9bab46aa0af23123b.gif
- RFC: https://tools.ietf.org/html/rfc5036

### PHP

**Penultimate Hop Popping** — оптимизация от бога, удаляем все метки на предпоследнем маршрутизаторе, чтобы не делать лишних лукапов в последнем.

Гифка: https://gblobscdn.gitbook.com/assets%2F-LIgRTPaaN7wUujKIWEz%2F-LfxxzdGb7gGgdgvPhmC%2F-Lfxzrl0AYwgGNeu29Rs%2F2c74499985d7463da7e67beac679038f-1.gif

### Про сходимость

Все сходится неплохо, но медленнее чем IGP, поэтому предлагается использовать MPLS TE (видимо резервные пути), чтобы избежать проблем при падении линка.

## VPN

С помощью MPLS можно сформировать провайдерский VPN.

Основные понятия для VPN:

**CE — Customer Edge router** — граничный маршрутизатор клиента, который подключен в сеть провайдера. 

**PE — Provider Edge router** — граничный маршрутизатор провайдера. Собственно к нему и подключаются CE. На PE зарождается VPN, на нём они и кончаются. Именно на нём расположены интерфейсы, привязанные к VPN. Именно PE назначает и снимает сервисные метки. Именно PE являются Ingress LSR и Egress LSR. PE должны знать таблицы маршрутизации каждого VPN, ведь это они принимают решение о том, куда посылать пакет, как в пределах провайдерской сети, так и в плане клиентских интерфейсов.

**P — Provider router** — транзитный маршрутизатор, который не является точкой подключения — пакеты VPN проходят через него без каких-либо дополнительных обработок, иными словами просто коммутируются по транспортной метке. P нет нужды знать таблицы маршрутизации VPN или сервисные метки. На P нет интерфейсов привязанных к VPN.

Основные понятия для MPLS:

Центральное понятие здесь **VRF** — Virtual Routing and Forwarding instance — нужна как гарантия чтобы ограничивать раутинг, если разные клиенты используют одни и те же частные сети (например 10.0.0.0/24). VRF — он строго локален для маршрутизатора — за его пределами VRF не существует. Соответственно VRF на одном маршрутизаторе никак не связан с VRF на другом.

MPLS VPN VRF создаются только на тех маршрутизаторах к которым подключены клиенты. Далее принадлежность к конкретному VPN определяется MPLS меткой. Остаётся вопрос, как найти выходной маршрутизатор и вообще проводить по этой метке раутинг.

![img](img/0_107085_688266c0_L.png)

Все верно, используем две метки — одну для раутинга на внутренних LSR, вторую для обозначения принадлежности к VPN, она будет использоваться только на Ingress и Egress. Заметим, что в качестве FEC в данной случае будет использоваться адрес последнего LSR в MPLS сети.

Конечно нужно как то выбрать одну метку для одного VPN на Ingress и Egress — для этого используется протокол MP-BGP. Его суть не сильно отличается от LDP.

Итого все вместе:

Маршрутизатор PE навешивает на клиентский трафик две метки — внутреннюю сервисную, которая не меняется до самого конца путешествия и по ней последний PE понимает, какому VRF принадлежит пакет, и внешнюю транспортную, по которой пакет передаётся через сеть провайдера — эта метка меняется на каждом P-маршрутизаторе и снимается на последнем PE или предпоследнем P (вспоминаем PHP). Благодаря наличию сервисной метки и VRF трафик различных VPN изолирован друг от друга как в пределах маршрутизаторов, так и в каналах.

## PS

Если хочется разобраться можно почитать слайды и СДСМ.

