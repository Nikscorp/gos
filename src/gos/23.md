# 23. Темпоральная логика деревьев вычислений CTL. Синтаксис и семантика CTL. Примеры спецификаций моделей в терминах формул CTL. Темпоральная логика линейного времени PLTL. Синтаксис и семантика PLTL. Свойства живости и безопасности. Ограничения справедливости. Задача верификации моделей (model-checking).

Модель Крипке $M$ над множеством атомарных высказываний $AP$  это четверка $M=(S,S_0, R,L)$:

* $S$ - конечное множество состояний
* $S_0 \sube S$ - множество начальных состояний
* $R \sube S \times S$ - отношение переходов, которое должно быть тотальным ( для каждого состояния $s\in S$ должно существовать такое состояние $s' \in S$, что имеет место $R(s,s')$) 
* $L: S \to 2^{AP}$ - функция разметки, которая помечает каждое состояние множеством атомарных высказываний, истинных в этом состоянии.

**Трасса** - последовательность событий (вычисление системы)

**Свойство системы** - множество трасс

Свойство вычислений P называется **свойством безопасности** ,если оно удовлетворяет следующему требованию: какова бы ни была трасса $\alpha$, $\alpha \in (2^{AP})^\omega \setminus P  $,  существует такой ее конечный префикс $\beta$, что для любой трассы $\alpha'$ выполняется соотношение $\beta\alpha' \notin P$.

Содержательный смысл: "отсутствие безопасности - это когда если что-то плохое случилось, то этого уже не исправить"

Свойство вычислений P называется **свойством живости** ,если оно удовлетворяет следующему требованию: для любого конечного слова $\beta$, $\beta \in (2^{AP})^*$,  существует такая  трасса  $\alpha$, $\alpha \in (2^{AP})^\omega$ , для которой выполняется соотношение $\beta\alpha \in P$.

Содержательный смысл: "что бы ни случилось в начале, потом всегда можно достичь своей цели"



Различают два типа **ограничений справедливости** ( условий, которым должны удовлетворять пути в моделях Крипке, чтобы эти пути соответствовали вычислениям, построенным по принципу чередования - важно для асинхронно работающих систем, чтобы только один процесс не выполнялся бесконечно часто).

* Слабая справедливость : если путь почти всегда проходит
  через состояния, в которых может быть выполнено
  действие act , то действие act должно быть выполнено
  бесконечно часто.
* Сильная справедливость : если путь бесконечно часто
  проходит через состояния, в которых может быть
  выполнено действие act , то действие act должно быть
  выполнено бесконечно часто.



Темпоральные логики предназначены для описания свойств вычислений реагирующих систем, т.е. множеств трасс в размеченных системах переходов (моделях Крипке).

**CTL***

**Синтаксис**

В CTL* имеются формулы двух типов: **формулы состояния** (способные обращаться в истину в некотором состоянии) и **формулы пути** (способные быть истинными на протяжении некоторого пути). Формулами CTL* называются все формулы состояний, полученные по следующим правилам.

Формулы состояния:

* $p \in AP$,  $p$ - формула состояния
* $f_1, f_2$ - формулы состояния, то $\neg f_1, f_1 \wedge f_2, f_1 \vee f_2 $ - формулы состояния
* $f$ - формула пути, то  **E**$f$ и **A**$f$ - формулы состояния

Формулы пути:

* $f$ - формула состояния, то $f$ - формула пути
* $g_1,g_2$ - формулы пути, то $\neg g_1, g_1 \wedge g_2, g_1 \vee g_2$, **X**$g_1$,  **F**$g_1$, $g_1$**U**$g_2$, $g_1$**R**$g_2$  - формулы пути

**Семантика**

Формул состояния:

* $M,s \models p$   $\Leftrightarrow$  $p \in L(s)$
* $M,s \models \neg f_1$   $\Leftrightarrow$  $M,s \nvDash f_1$
* $M,s \models f_1 \vee f_2$   $\Leftrightarrow$  $M,s \models f_1$ или $M,s \models f_2$
* $M,s \models f_1 \wedge f_2$   $\Leftrightarrow$  $M,s \models f_1$ и $M,s \models f_2$
* $M,s \models $**E**$f$ $\Leftrightarrow$ в $M$ есть такой путь $\pi$ из состояния $s$, что $M, \pi \models f$ (формула выполняется на протяжении пути)
* $M,s \models $**А**$f$ $\Leftrightarrow$ в $M$ для любого пути $\pi$ из состояния $s$, что $M, \pi \models f$ 

Формул пути:

* $M, \pi \models g_1$ $\Leftrightarrow$ для первого состояния $s$ на пути $\pi$ в $M$ верно $M,s \models g_1$
* $M,\pi \models \neg g_1$ $\Leftrightarrow$ $M, \pi \nvDash g_1$
* $M,\pi \models g_1 \vee g_2$   $\Leftrightarrow$  $M,\pi \models g_1$ или $M,\pi \models g_2$
* $M,\pi \models g_1 \wedge g_2$   $\Leftrightarrow$  $M,\pi \models g_1$ и $M,\pi \models g_2$
* $M,\pi \models$**X**$g_1$ $\Leftrightarrow$  $M, \pi^1 \models g_1$ ($\pi^i$ - это суффикc пути $\pi$ начинающийся из состояния $s_i$)
* $M,\pi \models$**F**$g_1$ $\Leftrightarrow$ существует такое $k \ge 0$, что $M, \pi^k \models g_1$
* $M,\pi \models$**G**$g_1$ $\Leftrightarrow$ для любого  $k\ge 0$ верно $M, \pi^k \models g_1$
* $M,\pi \models g_1$**U**$g_2$ $\Leftrightarrow$ существует такое $k\ge 0$ , что верно $M, \pi^k \models g_2$ и для каждого $0 \le j < k$ верно $M, \pi^j \models g_1$
* $M,\pi \models g_1$**R**$g_2$ $\Leftrightarrow$ каково бы ни было  $j\ge 0$ , если для каждого $i < j$ верно $M, \pi^i \nvDash g_1$, то  $M, \pi^j \models g_2$

CTL и LTL являются подмножествами CTL*. 

**CTL**

В логике ветвящегося времени темпоральные операторы находятся непосредственно под
действием кванторов по тем путям, которые исходят из заданного состояния. То есть каждый темпоральный оператор **X, F, G, U, R** должен следовать непосредственно за квантором пути **A, E**.

**Примеры спецификаций CTL**:

* **EF** (Start $ \wedge ~ \neg$ Ready): можно достичь такого состояния, в котором условие Start выполняется, а Ready - нет;
* **AG** (Req $\to$ **AF** Ack): когда бы ни был получен запрос, он рано или поздно будет подтвержден;
* **AG** (**AF** DeviceEnabled): условие DeviceEnabled выполняется бесконечно часто на каждом пути
  вычисления;
* **AG** (**EF** Restart): из любого достижимого состояния достижимо состояние Restart.

**LTL**

 В логике линейного времени операторы предназначены для описания событий на протяжении
единственного пути вычисления. Состоит из всех формул вида **A**$f$, где $f$ - формула пути, в которой все формулы состояния - это атомарные высказывания.

**Примеры спецификаций LTL**:

* **A** (**FG** enabled $\to$ **GF** fired)



**Задача model-cheking**

Пусть задана модель Крипке $M = (S,S_0 ,R,L)$, и формула темпоральной логики $\phi$, которая выражает некоторую желаемую спецификацию. Требуется найти в множестве $S$ подмножество $S_{\phi}$ всех состояний $s$ , в которых выполняется $\phi$, т.е. множество $S_{\phi} = \{s \in S | M,s \models \phi\}$ , и проверить выполнимость включения $S_0 \sube S _{\phi}$ .