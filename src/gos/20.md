**20. Коммуникационные протоколы. Ошибки, возникающие при передаче сообщений. Задача надежного обмена сообщениями. Симметричные протокол скользящего (раздвижного) окна: устройство протокола и обоснование его корректности. Протокол альтернирующего бита.[1, стр. 83-94]**

### **Короткая версия** (см подробную версию ниже)

Основное назначение коммуникационного протокола - передача данных, то есть получение информации от одного узла сети и доставка ее по назначению другому узлу сети. При передаче данных возможны ошибки (потеря, дублирование, искажение). Эти ошибки нужно обнаруживать и исправлять. Для этого в протоколе ведется учет состояния информации. Для использования состояния информации применяется управление соединением - инициализация и аннулирование состояния информации. Инициализация называется установлением соединения, а аннулирование - завершением соединения.  

**Симметричный протокол раздвижного окна** (коммуникационный протокол)

Предназначен для для обмена данными между двумя узлами сети, которые имеют прямое соединение (например, кабель). Асинхронный протокол, относящийся к уровню управления передачей данных (второй уровень модели OSI). Не будет рассматриваться управление соединением для этого протокола. Предполагается, что физическое соединение обычно функционирует непрерывно в течение долгого времени, а не устанавливается и завершается периодически. При физическом соединении сообщения не могут обгонять друг друга и дублироваться, поэтому рассматриваются только ошибки потери сообщения. Содержание сообщения, передаваемого по каналу связи может быть повреждено. Предполагается, что процесс-получатель способен обнаруживать искажения сообщений, например, при помощи счетчиков четности или кодирования с исправлением ошибок.

Постановка задачи:

Процессам $p$ и $q$ нужно передать данные $in_{p}$ и $in_{q}$ друг другу и записать полученные данные в $out_{p}$ и $out_{q}$. В канале связи возможны помехи, приводящие к потери сообщений.

Общая идея алгоритма:

* Входные данные одного процесса служат для подтверждения получения сообщений от другого процесса.
* Сообщение - пакеты - наборы вида $<pack, w, i>$, где $w$ - информационное слово, $i$ - порядковый номер пакета
* Пакет $<pack, w, i>$, отправленный процессом $p$, передает слово $w=in_{p}[i]$ процессу $q$ и подтверждает успешное получение ряда пакетов, отправленных процессом $q$.
* Процесс $p$ может опережать процесс $q$ на некоторое заданное число пакетов $l_{p}$, если мы постановим, что отправление пакета $<pack, w, i>$ процессом $p$ подтверждает получение слов с номерами $0, 1, ..., (i-l_p)$ от процесса $q$.
* Константы опережения $l_p$ и $l_q$ известны процессам $p$ и $q$.

Таким образом в протоколе соблюдаются два принципа:

* Процесс $p$ может отправить слово $in_p[i]$ только после того, как будут занесены в память все слова, начиная с $out_p[0]$ и заканчивая $out_p[i-l_p]$ , то есть когда будет выполняться неравенство $i<s_p+l_p$, где $s_p= min{j: out_p[j]=udef}$
* Как только $p$ получает пакет $<pack, w, i>$ отпадает необходимость в повторной передаче слов, начиная с $in_p[0]$ и оканчивая $in_p[i-l_q]$.

Алгоритм состоит из следующих трех действий:

* Действие $S_p$ осуществляет отправление $i$-го входного слова процесса $p$.

* Действие $R_p$ осуществляет прием слова процессом $p$.

* Действие $L_p$ моделирует потерю пакета, адресатом которого является процесс $p$.

**Требования корректности.** Нужно доказать, что протокол работает правильно, т.е. каждое слово из входного массива $in_p$ процесса p будет рано или поздно записано в выходной массив outq процесса $q$ , и наоборот. Более строго это выражается двумя требованиями. 

1. Безопасная доставка сообщений. В каждой достижимой конфигурации протокола выполняются соотношения $out_p[0..s_p-1]=in_q[0..s_p-1]$ и $out_q[0..s_q-1]=in_p[0..s_q-1]$ . 
2. Неизбежная доставка сообщений. Для каждого целого числа $k ≥ 0$ , в ходе выполнения протокола будет достигнута конфигурация, в которой $s_p≥ k$, $s_q≥ k$ .

Симметричный протокол удовлетворяет этим требованиям по теоремам.

**Теорема**. 

Симметричный протокол раздвижного окна удовлетворяет требованию безопасной доставки сообщений, т.е. в каждой достижимой конфигурации протокола выполняются соотношения $out_p[0..s_p-1]=in_q[0..s_p-1]$ и $out_q[0..s_q-1]=in_p[0..s_q-1]$

**Теорема**

Симметричный протокол раздвижного окна удовлетворяет требованию неизбежной доставки сообщений, т.е. для каждого целого числа k ≥ 0 , в ходе любого выполнения протокола будет достигнуты конфигурация, в которой spk, sqk.

**Протокол альтернирующего бита**

Особо интересный вариант протокола раздвижного окна возникает в том случае, когда $l_p=1$ и $l_q=0$ (или наоборот). В качестве начальных значений переменных $a_p$ и $a_q$ в этом случае выбирается не 0, а числа $-l_p$ и $-l_q$ . Такой вариант алгоритма раздвижного окна называется протоколом чередующихся (альтернирующих) битов; он предназначен для односторонней передачи данных.





### **Подробная версия**

Основное назначение коммуникационного протокола - передача данных, то есть получение информации от одного узла сети и доставка ее по назначению другому узлу сети. При передаче данных возможны ошибки (потеря, дублирование, искажение). Эти ошибки нужно обнаруживать и исправлять. Для этого в протоколе ведется учет состояния информации. Для использования состояния информации применяется управление соединением - инициализация и аннулирование состояния информации. Инициализация называется установлением соединения, а аннулирование - завершением соединения.  

**Симметричный протокол раздвижного окна** (коммуникационный протокол)

Предназначен для для обмена данными между двумя узлами сети, которые имеют прямое соединение (например, кабель). Асинхронный протокол, относящийся к уровню управления передачей данных (второй уровень модели OSI). Не будет рассматриваться управление соединением для этого протокола. Предполагается, что физическое соединение обычно функционирует непрерывно в течение долгого времени, а не устанавливается и завершается периодически. При физическом соединении сообщения не могут обгонять друг друга и дублироваться, поэтому рассматриваются только ошибки потери сообщения. Содержание сообщения, передаваемого по каналу связи может быть повреждено. Предполагается, что процесс-получатель способен обнаруживать искажения сообщений, например, при помощи счетчиков четности или кодирования с исправлением ошибок.

Постановка задачи:

Процессам $p$ и $q$ нужно передать данные $in_{p}$ и $in_{q}$ друг другу и записать полученные данные в $out_{p}$ и $out_{q}$. В канале связи возможны помехи, приводящие к потери сообщений.

Общая идея алгоритма:

* Входные данные одного процесса служат для подтверждения получения сообщений от другого процесса.
* Сообщение - пакеты - наборы вида $<pack, w, i>$, где $w$ - информационное слово, $i$ - порядковый номер пакета
* Пакет $<pack, w, i>$, отправленный процессом $p$, передает слово $w=in_{p}[i]$ процессу $q$ и подтверждает успешное получение ряда пакетов, отправленных процессом $q$.
* Процесс $p$ может опережать процесс $q$ на некоторое заданное число пакетов $l_{p}$, если мы постановим, что отправление пакета $<pack, w, i>$ процессом $p$ подтверждает получение слов с номерами $0, 1, ..., (i-l_p)$ от процесса $q$.
* Константы опережения $l_p$ и $l_q$ известны процессам $p$ и $q$.

Таким образом в протоколе соблюдаются два принципа:

* Процесс $p$ может отправить слово $in_p[i]$ только после того, как будут занесены в память все слова, начиная с $out_p[0]$ и заканчивая $out_p[i-l_p]$ , то есть когда будет выполняться неравенство $i<s_p+l_p$, где $s_p= min{j: out_p[j]=udef}$
* Как только $p$ получает пакет $<pack, w, i>$ отпадает необходимость в повторной передаче слов, начиная с $in_p[0]$ и оканчивая $in_p[i-l_q]$.

Действия алгоритма:

![img](https://lh3.googleusercontent.com/Sjvh8fyvl8_xyqwVXIV4zzlOuyCHODxYHe3D5Wae17qsZ9HBiW9_bzf_2Xu9fZbgohsg1zmw5be9HQf1UtNyCRLT9mHroVjrgkSN5kt0z0f-RvJH5UmcrhdD67VGWnjgCCaFHgRr)

Действие $S_p$ осуществляет отправление $i$-го входного слова процесса $p$.

Действие $R_p$ осуществляет прием слова процессом $p$.

Действие $L_p$ моделирует потерю пакета, адресатом которого является процесс $p$.

$S_p$:

Данные для отправления выбираются из раздвижного окна $a_p<i<s_p+l_p$. Предполагается, что $a_p$ наименьший номер в массиве $in_p$, получение которого еще не подтвердил процесс $q$, $s_p$ - наименьший номер того элемента в массиве $out_p$, в который еще не записаны полученные данные.

$R_p$:

Получив сообщение процесс в начале проверяет не было ли идентичное сообщение получено ранее (возникает повторное получение сообщения). Если это не так, то слово, содержащееся в сообщении, записывается в выходной массив, при этом значения переменных $a_p$ и $s_p$ изменяются. 

$L_p$:

Моделирование потери сообщения проводится путем удаления произвольного сообщения из множества сообщений $Q_p$ , пребывающих на этапе пересылки от процесса $q$ к процессу $p$.

Что плохого может случиться? 

1. Створки окон обоих процессов могут “захлопнуться”, и процессы будут обречены (безуспешно) ожидать сообщений друг от друга (блокировка , deadlock ); 
2. Створки окон могут “застыть”, и процессы будут обречены передавать одни и те же сообщения (активный тупик , livelock ); 
3. Данные могут быть потеряны при передаче, и процесс не заметит этого; 
4. Процесс может “забыть” передать данные; 
5. Створки окна могут раздвигаться, отдаляясь друг от друга неограниченно широко.

**Требования корректности.** Нужно доказать, что протокол работает правильно, т.е. каждое слово из входного массива $in_p$ процесса p будет рано или поздно записано в выходной массив outq процесса $q$ , и наоборот. Более строго это выражается двумя требованиями. 

1. Безопасная доставка сообщений. В каждой достижимой конфигурации протокола выполняются соотношения $out_p[0..s_p-1]=in_q[0..s_p-1]$ и $out_q[0..s_q-1]=in_p[0..s_q-1]$ . 
2. Неизбежная доставка сообщений. Для каждого целого числа $k ≥ 0$ , в ходе выполнения протокола будет достигнута конфигурация, в которой $s_p≥ k$, $s_q≥ k$ .

Многие свойства распределенных алгоритмов, нуждающиеся в проверке, относятся к одному из двух типов: условие безопасности и условие живости.

Условие безопасности требует, чтобы каждая достижимая конфигурация в любом выполнении системы обладала определенным свойством. Условие живости требует, чтобы хотя бы одна достижимая конфигурация в любом выполнении системы обладала определенным свойством.

Ограничения накладываемые, чтобы протокол обладал свойством живости:

* В качестве $l_p$ и $l_q$ можно взять любые неотрицательные константы, удовлетворяющие неравенству $l_p+l_q>0$ . 
* Выдвигаются два требования справедливости: 
  1. F1. Если бесконечно часто возникает возможность отправки пакета, то этот пакет будет отправляться бесконечно часто.
  2. F2. Если один и тот же пакет отправляется бесконечно часто, то и принимается он также бесконечно часто.

**Теорема**. 

Симметричный протокол раздвижного окна удовлетворяет требованию безопасной доставки сообщений, т.е. в каждой достижимой конфигурации протокола выполняются соотношения $out_p[0..s_p-1]=in_q[0..s_p-1]$ и $out_q[0..s_q-1]=in_p[0..s_q-1]$

Доказательство:

Следует из Теоремы 3.2 (о свойстве инвариантов) и Теоремы 3.4. Из условий 

(0p):  $\forall i <s_p: out_p[i] \ne udef$ и 

(2p): $\forall i: out_p[i] \ne udef  => out_p[i]=in_q[i] \land (a_p>i-l_q)$ следует выполнимость равенства $out_p[0..s_p-1]=in_q[0..s_p-1]$ , а из условий (0q) и (2q) следует выполнимость равенства $out_q[0..s_q-1]=in_p[0..s_q-1]$ .

Вспомогательные теоремы (без доказательства)

Теорема 3.2. Если $Q$ является инвариантом системы переходов $S$ , и для каждой конфигурации $γ ∈ C$ выполняется $Q(γ) => P(γ)$, то для любого выполнения системы $S$ утверждение $P$ будет истинно в каждой конфигурации выполнения.

Теорема 3.4. Утверждение P является инвариантом алгоритма раздвижного окна.

$$P \equiv \forall i < s_p: out_p[i] \ne udef  $$

$$\land  \forall i < s_q: out_q[i] \ne udef$$ 

$$\land \forall i: <pack, w, i> \in Q_p => w=in_q[i] \land (i<s_q+l_q)$$ 

$$\land \forall i: <pack, w, i> \in Q_q => w=in_p[i] \land (i<s_p+l_p)$$ 

$$\land \forall i: out_p[i] \ne udef => out_p[i]=in_q[i] \land (a_p>i-l_q)$$ 

$$\land \forall i: out_q[i] \ne udef => out_q[i]=in_p[i] \land (a_q>i-l_p)$$  

$$a_p \le s_q$$   

$$a_q \le s_p$$

**Теорема**

Симметричный протокол раздвижного окна удовлетворяет требованию неизбежной доставки сообщений, т.е. для каждого целого числа k ≥ 0 , в ходе любого выполнения протокола будет достигнуты конфигурация, в которой spk, sqk.

Доказательство:

Предположим, что есть вычисление C , в котором значения хотя бы одной из переменных $s_p$ и $s_q$ увеличиваются лишь конечное число раз. Тогда, согласно неравенству Леммы 3.1. $s_p − l_q ≤ s_q ≤ s_p + l_p$ , значение другой переменной также не может увеличиваться бесконечно часто. Пусть $\sigma_p$ и $\sigma_q$ - наибольшие значения переменных $s_p$ и $s_q$ . Тогда, cогласно Лемме 3.2., либо отправление пакета $<pack, in_p[\sigma_q], \sigma_q>$ процессом $p$ , либо отправление пакета $<pack, in_q[\sigma_p], \sigma_p>$ процессом $q$ допустимо бесконечно долго после того, как переменные $s_p$ , $s_q$ , $a_p$ и $a_q$ примут свои окончательные значения. Тогда, cогласно допущению F1, один из этих пакетов (например, $<pack,in_q[\sigma_p],\sigma_p>$ отправляется бесконечно часто, и, согласно допущению F2, он должен приниматься также бесконечно часто. Получение процессом $p$ пакета $<pack, in_q[\sigma_p], \sigma_p>$ приводит к тому, что значение $s_p$ (равное $\sigma_p$ ) увеличивается. Это противоречит выбору значения $\sigma_p$ .

Леммы будут приведены без доказательств

Лемма 3.1. В любой достижимой конфигурации выполняются неравенства $s_p − l_q ≤ a_p ≤ s_q ≤ a_q + l_p ≤ s_p + l_p$.(Створки окон процессов $p$ и $q$ “разъезжаются” не слишком далеко друг от друга.)

Лемма 3.2. В любой достижимой конфигурации допустимо хотя бы одно из двух действий: отправление пакета $<pack, in_p[s_q],s_q>$ процессом $p$ или отправление пакета $<pack, in_q[s_p],s_p>$ процессом $q$ .

**Протокол альтернирующего бита**

Особо интересный вариант протокола раздвижного окна возникает в том случае, когда $l_p=1$ и $l_q=0$ (или наоборот). В качестве начальных значений переменных $a_p$ и $a_q$ в этом случае выбирается не 0, а числа $-l_p$ и $-l_q$ . Такой вариант алгоритма раздвижного окна называется протоколом чередующихся (альтернирующих) битов; он предназначен для односторонней передачи данных.

