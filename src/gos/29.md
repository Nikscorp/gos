# 29. Псевдополиномиальные алгоритмы решения задач: разбиение, рюкзак, расписание для многопроцессорной системы (число процессоров фиксировано).

Пусть есть задача распознавания свойств $П$. $D_{П}$ - множество индивидуальных задач.

Алгоритм $A$ решения задачи $П$ называется псевдополиномиальным, если его вычислительная сложность ограничена сверху полиномом  от функции длины и функции максимума (максимальное число в данной индивидуальной задаче) :      $T_A(I) \le p(l(I),M(I))$        ($I \in D_{П}$)

**Разбиение**

Пусть даны $n$ чисел : $N = \{a_1, \dots, a_n\}$. Такие, что  $B = \sum\limits_{i \in N} a_i$ - четное число и  $0 < a_i < {B\over 2}|~  i=\overline{1,n}$. Необходимо проверить, возможно ли разбиение множества $N$ на два непересекающихся подмножества $\overline N$ и $N \setminus \overline N$, таких, что $\sum\limits_{i \in \overline N} a_i = \sum\limits_{j \in N \setminus \overline N} a_j = {B \over 2}$

Алгоритм:

Необходимо составить таблицу $t(i,j)$ размера $n \times {B \over 2}$.

Значение ячейки $t(i,j) = \left\{ \begin{matrix} 1 & \exist\tilde N \sube N' : \sum\limits_{k \in \tilde N} a_k = j~ ,~ при~ этом ~ N' = \{a_1, \dots, a_i\} \\ 0 & иначе  \end{matrix} \right.$

Построение таблицы производится по строкам, начиная с первой:

* В первой строке $i=1$ единица ставится столбцу $j = a_1$ :    $t(1, a_1) = 1$
* Для следующих строк $i > 1$:
  1. Переносим все единицы с предыдущей строки:  $t(i, j) = 1$, если $t(i-1,j) = 1$
  2. Добавляем единицы, полученные сдвигом существующих на $a_i$:  если $t(i-1, j) = 1$ и $ j + a_i \le {B \over 2}$,  то  $t(i, j+ a_i) = 1$
  3. Добавляем единицу в столбец с номером $a_i$:  $t(i, a_i) = 1$ 

Останавливаемся, когда получаем первую единицу в столбце с номером $B \over 2$ - значит можно построить разбиение. Если нет, то и нельзя построить разбиение.

Сложность алгоритма равна $O(nB)$ - по размеру таблицы, которую надо заполнить.

**Рюкзак**

Дано $n$ предметов с весами $w_1, \dots, w_n$ и стоимостями $p_1, \dots, p_n$.  $N = \{ 1, \dots, n\}$.  Задан вес $W$ и стоимость $P$. Необходимо проверить, возможно ли найти такое множество предметов $\overline{N}$ , что сумма их весов не превышает заданный вес $\sum\limits_{i \in \overline N} w_i \le W$  и  суммарная стоимость не меньше заданной стоимости $\sum\limits_{i \in \overline N} p_i \ge P$ .

Алгоритм:

Необходимо составить таблицу $t(i,j)$ размера $n \times W$.

Построение таблицы производится по строкам, начиная с первой:

* В первой строке $i=1$ ячейка со столбцом $j = w_1$ заполняется стоимостью $p_1$  :    $t(1, w_1) = p_1$
* Для следующих строк $i > 1$:
  1. Переносим все значения c предыдущей строки:  $t(i, j) = t(i-1, j)$   $j  = \overline{1, W}$
  2. Выбираем максимальную стоимость между 2 вариантам: добавить $i$ -ую вещь в наборы или не добавлять (уже есть набор с таким же весом и большей стоимостью)  :  если $t(i,j) \neq 0$, то $t(i, j + w_i) = \max\{ t(i-1,j) + p_i, ~~ t(i-1,j+w_i) ~ \}$ 
  3. Добавляем максимальную стоимость для множества с весом $w_i$:  $t(i, w_i) = \max \{p_i,~~ t(i-1, w_i) \}$

Останавливаемся, когда получаем значение стоимости в ячейке, больше, чем $P$, - значит можно найти необходимое множество предметов. Если не получили, то и нельзя найти необходимое множество предметов.

Теперь перейдем к поиску самого набора предметов, в случае, если необходимое множество предметов найти можно:

1. Изначально множество $N'$ пусто
2. Выбираем минимальную строку $i_1$, такую, что $\exist j_1 : t(i_1,j_1) \ge P$. Добавляем $i_1$ к $N'$. Запоминаем $j_1$
3. Уменьшаем $j_1$ на величину веса предмета $i_1$: $j_1 := j_1 - w_{i_1}$
4. Если $j_1 = 0$, то закончили. Иначе ищем минимальную строку $i_2$, такую, что $t(i_2, j_1) = t(i_1, j_1)$. Добавляем $i_2$ в множество $N'$.   $i_1 := i_2$  и переход к шагу 3.

Сложность алгоритма равна $O(nW)$ - по размеру таблицы, которую надо заполнить.

**Расписание для многопроцессорной системы**

Пусть задано $N = \{1, \dots, n\}$ работ с заданными длительностями выполнения $t_i \le T$.  $T$ - единый директивный срок для всех работ. Имеется $m$ процессоров на которых запрещены прерывания. Необходимо проверить - возможно ли построение расписания выполнения работ, которое уложится в директивный интервал.

Алгоритм:

Алгоритм заключается в построении точек в $m$-мерной решетке и проверки принадлежности точек $m$-мерному кубу со стороной $T$.

1. $l=1 $ - cтроим первые $m$ точек $m$-мерной решетки: $(t_1, 0, \dots, 0), (0, t_1, \dots, 0), \dots, (0,0,\dots,t_1)$ . Изначально все эти точки активны.
2. Исключаем из списка активных точек те, которые не принадлежат определенному выше кубу. Если $l = n$, то решение найдено - из числа активных точек берем решение. Если активных не осталось, то расписание не может построить, удовлетворяющее директивному интервалу $T$.
3. На шаге $l := l+1$  для каждой активной точки  $a =(a_1, a_2, \dots, a_m)$ строим множество новых активных точек вида $(a_1 + t_l, a_2, \dots, a_m), (a_1, a_2 + t_l, \dots, a_m), \dots, (a_1,a_2,\dots,a_m + t_l)$ , при этом $a$ исключаем из списка активных. Переходим к шагу 2.

Сложность $O(T^m)$ - псевдополиномиальный только при фиксированном числе процессоров $m$.

> T^m - число точек рассматриваемого куба, которые проверяем

